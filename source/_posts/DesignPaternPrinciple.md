---
layout: post
title: 设计模式：软件设计原则
date: 2019-2-11 21：06
category: 设计模式
tags: [设计模式]
description: 本文涉及到软件设计时，常常用到的一些原则：单一职责原则(SRP)、开放封闭原则等等。
---



### 软件设计原则



#### 一、单一职责原则

​	**对一个类而言，应该有且仅有一个引起它变化的原因。**当我们可以想到多于一个动机去改变一个类，那么这个类就多于一个职责，此时我们就需要考虑职责分离。



#### 二、开放-封闭原则

​	**软件实体（类、函数、模块等）可扩展，但不可修改。**即对扩展开放，对修改封闭。	它可以帮助实现：面对需求的改变可以保持稳定，使得系统可在第一版本之后不断推进产生新的版本。



##### 优点(why)

- **开放-封闭原则可以带来面向对象编程的可维护、可扩展、可复用、灵活性好的优点。**对程序中频繁变化的部分抽象，然而对程序中每个部分都进行刻意的抽象并不好，要拒绝不成熟的抽象很重要。



##### 如何做(How)

​	在实践中总会存在一些无法对封闭的变化出现，既然不可能完全封闭，我们就需要对哪种变化封闭做出选择。

- **尽可能猜测出可能发生变化的种类，然后抽象隔离这些变化。**当变化发生时立即采取行动。
- 在最初实现代码时，假设变化不会发生，当变化发生时，我们可以创建抽象来隔离之后可能发生的同类变化。
- **面对需求，对程序改动是通过新增代码进行的，而不是更改现有的代码。**比如工厂模式中的计算器，如果在原有的加减乘除基础上添加平方、立方运算。



#### 三、里氏代换原则(LSP)

​	一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且察觉不出父类对象和子类对象的区别，也就是说，在软件中把父类都替换为子类，程序的行为无变化。**简单点儿描述，子类型必须能够替换掉他们的父类型。**现实类似的像是应用场景，电脑内部的器件坏掉可以维修，而收音机坏掉却无法维修。



#### 四、依赖倒转原则

​	**高层模块不应该依赖于底层模块，两个都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。**也就是针对接口编程，而不要针对实现编程。类似的显示应用场景，比如电脑中的CPU、内存等设备坏掉可以真毒单一设备更换，里面的设备可以是Intel的，也可以是其他家的。



#### 五、埃米特法则(LoD.最少只是原则)

​	**如果两个类不必发生彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果另外一个类需要调用两个类的某个方法的话，可以直接通过第三者转发这个调用。**这个法则重点强调：

- 类的结构设计上，每个类都应当尽量降低成员的访问权限。
- **根本思想是强调类间的松耦合。**类间耦合越弱，越有利于复用，若耦合的类被修改，不会对有关系的类造成波及。



#### 六、合成/聚合原则(CARP)

​	**尽量使用合成/聚合，尽量不要使用类继承。**聚合表示一种“弱拥有”关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分；合成则是一种“强拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。出现该原则的原因有：

- **继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的**，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；**从基类继承而来的实现是静态的，不可能在运行时发生改变**，没有足够的灵活性；而且**继承只能在有限的环境中使用**，子类的实现与它的父类有非常密切的依赖关系，以至于父类实现中的任何变化必然会导致子类的变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他的类替换，这种依赖关系限制了灵活性并最终限制了可复用性。



##### 优点

- **有助于保持每个类被封装，被集中在单个任务上。**这样类和类继承层次保持较小的规模，并不太可能增长为庞然大物。

  ```shell
  		手机品牌《——————————————————手机软件
  		   |						|
  手机品牌N		手机品牌N	   通讯录		  游戏
  ```


##### 适用场景(when)

###### 1、使用“Has-A”和“Is-A”来判断

​	"Is－A”代表一个类是另外一个类的一种，可以使用继承关系。”Has-A”代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类



###### 2、使用里氏代换原则来判断

​      里氏代换原则是继承复用的基础



#### 七、敏捷开发原则

​	**敏捷开发原则指的是不要为代码添加基于猜测的，实际不需要的功能。入股不清楚一个系统是否需要，一般不要着急去实现它，事实上，在需要的时候通过代码重构实现该模式并不困难。**

