---
layout: post
title: 设计模式：软件设计原则
date: 2019-2-11 21：06
category: 设计模式
tags: [设计模式]
description: 本文涉及到软件设计时，常常用到的一些原则：单一职责原则(SRP)、开放封闭原则等等。
---



### 软件设计原则



#### 一、单一职责原则

​	**对一个类而言，应该有且仅有一个引起它变化的原因。**当我们可以想到多于一个动机去改变一个类，那么这个类就多于一个职责，此时我们就需要考虑职责分离。



#### 二、开放-封闭原则

​	**软件实体（类、函数、模块等）可扩展，但不可修改。**即对扩展开放，对修改封闭。	它可以帮助实现：面对需求的改变可以保持稳定，使得系统可在第一版本之后不断推进产生新的版本。



##### 优点(why)

- **开放-封闭原则可以带来面向对象编程的可维护、可扩展、可复用、灵活性好的优点。**对程序中频繁变化的部分抽象，然而对程序中每个部分都进行刻意的抽象并不好，要拒绝不成熟的抽象很重要。



##### 如何做(How)

​	在实践中总会存在一些无法对封闭的变化出现，既然不可能完全封闭，我们就需要对哪种变化封闭做出选择。

- **尽可能猜测出可能发生变化的种类，然后抽象隔离这些变化。**当变化发生时立即采取行动。
- 在最初实现代码时，假设变化不会发生，当变化发生时，我们可以创建抽象来隔离之后可能发生的同类变化。
- **面对需求，对程序改动是通过新增代码进行的，而不是更改现有的代码。**比如工厂模式中的计算器，如果在原有的加减乘除基础上添加平方、立方运算。



#### 三、里氏代换原则(LSP)

​	一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且察觉不出父类对象和子类对象的区别，也就是说，在软件中把父类都替换为子类，程序的行为无变化。**简单点儿描述，子类型必须能够替换掉他们的父类型。**现实类似的像是应用场景，电脑内部的器件坏掉可以维修，而收音机坏掉却无法维修。



#### 四、依赖倒转原则

​	**高层模块不应该依赖于底层模块，两个都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。**也就是针对接口编程，而不要针对实现编程。类似的显示应用场景，比如电脑中的CPU、内存等设备坏掉可以真毒单一设备更换，呢欧村设备可以是Intel的，也可以是其他家的。



#### 五、埃米特法则(最少只是原则)